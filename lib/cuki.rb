require 'rubygems'
require 'httpclient'
require 'nokogiri'
require 'yaml'
require 'CGI'
require 'json'
require 'parallel'
require File.dirname(__FILE__) + '/string_utils.rb'

# terrible hack
if File.exist?('stubs.json') || File.exist?('stubs.json')
  require 'webmock'
  include WebMock::API
end

class Cuki

  CONFIG_PATH = 'config/cuki.yaml'

  def self.invoke(args)
    new(args)
  end

  def initialize(args)
    validate_args args
    read_config
    configure_http_client

    action = args.first
    if args.include?('--skip-autoformat')
      args.delete_if { |arg| '--skip-autoformat' == arg }
      @skip_autoformat = true
    end
    if args.include?('--skip-header')
      args.delete_if { |arg| '--skip-header' == arg }
      @skip_header = true
    end
    if 'pull' == action
      configure_pull_stubs
      verify_project
      file = args[1]
      if file
        id = @config['mappings'].invert[file]
        raise "could not get id for #{file}" unless id
        pull_feature id, file
      else
        Parallel.map(@config['mappings'], :in_processes => 4) do |id, filepath|
          pull_feature id, filepath
        end
      end
      autoformat
    elsif 'push' == action
      configure_push_stubs
      Pusher.push file, @config
    else
      puts "Unknown action '#{action}"
      exit(1)
    end
  end

  private
  
  def verify_project
    # check features folder exists
    raise "features folder not found" unless File.exists?('features')
    autoformat
  end
  
  def read_config
    unless File.exist?(CONFIG_PATH)
      puts "No config file found at #{CONFIG_PATH}"
      exit(1)
    end
    @config = YAML::load( File.open( CONFIG_PATH ) )
    raise "Host not found in #{CONFIG_PATH}" unless @config["host"]
    raise "Mappings not found in #{CONFIG_PATH}" unless @config["mappings"]
  end
  
  def configure_http_client
    @client = HTTPClient.new
    @client.ssl_config.set_trust_ca(ENV['CER']) if ENV['CER']
    @client.ssl_config.set_client_cert_file(ENV['PEM'], ENV['PEM']) if ENV['PEM']
  end
  
  def pull_feature(id, filepath)
    @content = ''
    wiki_edit_link = @config['host'] + '/pages/editpage.action?pageId=' + id.to_s
    wiki_view_link = @config['host'] + '/pages/viewpage.action?pageId=' + id.to_s
    puts "Downloading #{wiki_edit_link}"
    response = @client.get wiki_edit_link
    doc = Nokogiri(response.body)

    unless doc.at('#content-title')
      puts "Not a valid confluence page:"
      puts doc.to_s
      exit(1)
    end
    
    
    unless filepath.include?('.feature')
      
      @config['container'] ||= /h1\. Acceptance Criteria(.*)h1\./m
      
      handle_multi doc, id
    else

      @content += "Feature: " + doc.at('#content-title')[:value] + "\n\n"
      @content += "#{wiki_view_link}\n\n"
      @content += get_markup(doc)

      clean

      process_tags

      @content = "# Generated by Cuki (#{Time.now})\n" + @content unless @skip_header

      save_file filepath
    end
  end
  
  def autoformat
    `cucumber -a . --dry-run -P` unless @skip_autoformat
  end
  
  def handle_multi doc, id
    feature_title_compressed = doc.at('#content-title')[:value].anchorize

    @content += get_markup(doc)
    acceptance_criteria_matches = @content.match(@config['container'])
    unless acceptance_criteria_matches
      puts "Could not match #{config['container']}" 
      exit(1)
    end
    acceptance_criteria = acceptance_criteria_matches[1]
    scenario_titles = acceptance_criteria.scan(/h2. (.*)/).flatten
    scenario_blocks = acceptance_criteria.split(/h2. .*/)
    scenario_blocks.shift

    combined = {}
    scenario_titles.each_with_index do |title, index|
      combined[title] = scenario_blocks[index].gsub(/h6. (.*)/, '\1')
    end
    combined.each do |title, content|
      scenario_title_compressed = title.anchorize
      feature_filename = title.parameterize

      dirpath = @config['mappings'][id]

      FileUtils.mkdir_p(dirpath)
      
      fname = "#{dirpath}/#{feature_filename.gsub("\r", '')}.feature"
      File.open(fname, 'w') do |f|
        puts "Writing #{fname}"
        f.write "Feature: #{title}\n\n"
        link = @config['host'] + "/pages/viewpage.action?pageId=#{id}##{feature_title_compressed}-#{scenario_title_compressed}"
        f.write "\n\n" + link
        f.write content
      end
    end
  end
  
  def clean
    
    @content.gsub!('&nbsp;', '')
    
    # remove the double pipes used for table headers in Confluence
    @content.gsub!('||', '|')

    # remove other noise
    @content.gsub!("\r\n", "\n")
    @content.gsub!("\\\\\n", '')
    @content.gsub!('\\', '')

    # remove any unwanted headers
    @content.gsub!(/h\d\. (Scenario: .*)/, '\1')
    @content.gsub!(/h\d\. (Scenario Outline: .*)/, '\1')
    @content.gsub!(/h\d\. (Background: .*)/, '\1')
    
    #Remove fancy quotes
    @content.gsub!('’', "'")
    @content.gsub!('‘', "'")
    @content.gsub!('“', '"')
    @content.gsub!('”', '"')

  end
  
  def process_tags
    tags = []
    if @config['tags']
      @config['tags'].each_pair do |tag, snippet|
        tags << "@#{tag}"  if @content.include?(snippet)
      end
    end
    unless tags.empty?
      @content = tags.join(' ') + "\n" + @content
      tags.each do |tag|
        @content.gsub!(@config['tags'][tag.gsub('@', '')], '')
      end
    end
  end
  
  def save_file(filepath)
    dir_path = File.dirname(filepath)

    FileUtils.mkdir_p(dir_path) unless File.exists?(dir_path)

    File.open(filepath, 'w') do |f|
      puts "Writing #{filepath}"
      f.puts @content
    end
  end
  
  def configure_pull_stubs
    if File.exist?('stubs.json')
      stubs = JSON.parse(File.open('stubs.json').read)
      stubs.each_pair do |url, body|
        stub_request(:get, url).to_return(:status => 200, :body => body, :headers => {})
      end
      FileUtils.rm 'stubs.json'
    end
  end
  
  def configure_push_stubs
    if File.exist?('push_stubs.json')
      stubs = JSON.parse(File.open('push_stubs.json').read)
      stubs.each do |a|
        stub_request(:post, "http://mywiki/").
                with(:body => {"title" => a['title'], "content"=> "\n\n" + a['content']},
                     :headers => {'Content-Type'=>'application/x-www-form-urlencoded'}).
                to_return(:status => 200, :body => "", :headers => {})
      end
      FileUtils.rm 'push_stubs.json'
    end
  end
  
  def validate_args args
    if args.empty?
      puts "No action given"
      exit(1)
    end
  end
  
  def get_markup(doc)
    CGI.unescapeHTML(doc.css('#markupTextarea').text)
  end
  
end
